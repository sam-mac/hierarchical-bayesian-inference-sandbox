"""Plotly helpers for exploring hierarchical synthetic data.

These utilities visualise the panel generated by
:func:`bayes_tools.helpers.synthetic_data_helpers.make_hierarchical_ou_dataset`.
They lean on Plotly so that downstream notebooks can embed interactive charts.
"""

from __future__ import annotations

from typing import Optional, Sequence

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

from .synthetic_data_helpers import aggregate_to_parent

# ---------------------------------------------------------------------------
# Data preparation
# ---------------------------------------------------------------------------


def _prepare_panel(
    df: pd.DataFrame,
    level: str = "ou",
    groups: Optional[Sequence[str]] = None,
) -> pd.DataFrame:
    """Return a tidy panel ready for plotting.

    Parameters
    ----------
    df:
        Data frame produced by :func:`make_hierarchical_ou_dataset`.
    level:
        Granularity for the plot (``"ou"``, ``"site"`` or ``"region"``).
    groups:
        Optional whitelist of group identifiers to retain. The identifiers
        depend on the level: ``ou`` expects ``ou_code`` strings, ``site`` uses
        ``site_id`` and ``region`` uses ``region_id``.
    """

    level = level.lower()
    if level not in {"ou", "site", "region"}:
        raise ValueError("level must be one of {'ou', 'site', 'region'}")

    if level == "ou":
        panel = df.copy()
        panel = panel.rename(columns={"ou_code": "group_id"})
    else:
        panel = aggregate_to_parent(df, level=level)
        panel = panel.rename(columns={f"{level}_id": "group_id"})

    panel["level"] = level
    panel["date"] = pd.to_datetime(panel["date"])

    if groups is not None:
        panel = panel.loc[panel["group_id"].isin(groups)].copy()
        if panel.empty:
            raise ValueError(
                "No rows remain after applying the provided group filters. "
                "Check that group identifiers match the requested level."
            )

    return panel


# ---------------------------------------------------------------------------
# Plot builders
# ---------------------------------------------------------------------------


def plot_metric_timeseries(
    df: pd.DataFrame,
    metric: str = "productivity",
    *,
    level: str = "ou",
    groups: Optional[Sequence[str]] = None,
    show_survey_markers: bool = True,
    rolling_window: Optional[int] = None,
) -> go.Figure:
    """Line chart of a monthly metric for one or more groups.

    Parameters
    ----------
    metric:
        Column to plot on the Y axis. Defaults to ``"productivity"``.
    level, groups:
        Passed to :func:`_prepare_panel`.
    show_survey_markers:
        When ``True`` markers are overlaid on months with a survey response
        (where ``survey_score`` is not missing).
    rolling_window:
        Optional rolling window size (in months). When provided a smoothed
        series is added as a dashed line.
    """

    panel = _prepare_panel(df, level=level, groups=groups)

    if metric not in panel.columns:
        raise ValueError(f"Column '{metric}' is not present in the data frame")

    fig = px.line(
        panel,
        x="date",
        y=metric,
        color="group_id",
        title=f"{metric.replace('_', ' ').title()} by {level.title()}",
        labels={"group_id": f"{level.title()} id", "date": "Month"},
    )

    if show_survey_markers and "survey_score" in panel.columns:
        survey_rows = panel[panel["survey_score"].notna()]
        if not survey_rows.empty:
            fig.add_trace(
                go.Scatter(
                    x=survey_rows["date"],
                    y=survey_rows[metric],
                    mode="markers",
                    marker=dict(symbol="circle", size=8, color="black"),
                    name="Survey wave",
                    legendgroup="survey",
                )
            )

    if rolling_window and rolling_window > 1:
        smooth = (
            panel.sort_values(["group_id", "date"])
            .groupby("group_id")[metric]
            .transform(lambda s: s.rolling(rolling_window, min_periods=1).mean())
        )
        panel = panel.assign(_smoothed=smooth)

        smooth_fig = px.line(
            panel,
            x="date",
            y="_smoothed",
            color="group_id",
            labels={"group_id": f"{level.title()} id", "date": "Month"},
        )
        for trace in smooth_fig.data:
            trace.update(line=dict(dash="dash"), name=f"{trace.name} (smooth)")
            fig.add_trace(trace)

    fig.update_layout(legend_title_text=f"{level.title()} id")
    return fig


def plot_productivity_vs_survey(
    df: pd.DataFrame,
    *,
    level: str = "ou",
    groups: Optional[Sequence[str]] = None,
    colour_by_productivity: bool = True,
) -> go.Figure:
    """Scatter plot comparing survey scores to productivity.

    Only months with survey responses are included. Each point is one month
    at the requested aggregation level.
    """

    panel = _prepare_panel(df, level=level, groups=groups)
    survey_rows = panel.dropna(subset=["survey_score"])
    if survey_rows.empty:
        raise ValueError("No survey responses available to plot.")

    hover = ["group_id", "date", "productivity", "survey_score", "fte_operational"]
    hover = [col for col in hover if col in survey_rows.columns]

    colour = "productivity" if colour_by_productivity else "group_id"

    fig = px.scatter(
        survey_rows,
        x="productivity",
        y="survey_score",
        color=colour,
        size="n_respondents" if "n_respondents" in survey_rows else None,
        hover_data=hover,
        title=f"Survey vs productivity ({level})",
        labels={
            "productivity": "Productivity",
            "survey_score": "Survey score",
            "n_respondents": "Respondents",
        },
    )

    if colour_by_productivity:
        fig.update_traces(marker=dict(colorscale="Viridis"))

    return fig


def plot_survey_heatmap(
    df: pd.DataFrame,
    *,
    level: str = "ou",
    groups: Optional[Sequence[str]] = None,
    value: str = "survey_score",
) -> go.Figure:
    """Heatmap of survey-related metrics across groups and time.

    Useful for spotting missing waves or drifts in respondent counts.
    """

    panel = _prepare_panel(df, level=level, groups=groups)
    if value not in panel.columns:
        raise ValueError(f"Column '{value}' is not present in the data frame")

    # Pivot to month index and group columns for heatmap
    pivot = (
        panel.assign(date=panel["date"].dt.to_period("M"))
        .pivot_table(index="date", columns="group_id", values=value)
        .sort_index()
    )

    fig = go.Figure(
        data=go.Heatmap(
            z=pivot.to_numpy(),
            x=pivot.columns.astype(str),
            y=pivot.index.astype(str),
            colorscale="Blues",
            colorbar=dict(title=value.replace("_", " ").title()),
            hovertemplate="Group %{x}<br>Month %{y}<br>Value %{z:.2f}<extra></extra>",
        )
    )

    fig.update_layout(
        title=f"{value.replace('_', ' ').title()} heatmap ({level})",
        xaxis_title=f"{level.title()} id",
        yaxis_title="Month",
    )
    return fig


def plot_headcount_vs_productivity(
    df: pd.DataFrame,
    *,
    level: str = "ou",
    groups: Optional[Sequence[str]] = None,
) -> go.Figure:
    """Bubble chart comparing operational FTE and productivity.

    Aggregates to the requested level and colour codes points by group.
    """

    panel = _prepare_panel(df, level=level, groups=groups)
    latest = (
        panel.sort_values("date")
        .groupby("group_id")
        .tail(1)
        .dropna(subset=["fte_operational", "productivity"])
    )
    if latest.empty:
        raise ValueError("No rows with both FTE and productivity to plot.")

    fig = px.scatter(
        latest,
        x="fte_operational",
        y="productivity",
        size="productivity",
        color="group_id",
        hover_data=["date"],
        labels={
            "fte_operational": "Operational FTE",
            "productivity": "Productivity",
        },
        title=f"Latest month productivity vs FTE ({level})",
    )
    return fig


__all__ = [
    "plot_metric_timeseries",
    "plot_productivity_vs_survey",
    "plot_survey_heatmap",
    "plot_headcount_vs_productivity",
]
